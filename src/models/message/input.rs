use super::QueryType;

/// A struct that combines a query and an input into a single struct.
///
/// This is for the purpose of passing a complete set of HTTP request data to the handler,
/// allowing the freedom to design a REST structure that fits the application's needs.
#[derive(Debug, Clone, serde::Serialize)]
pub struct CombinedInput<Q, I>
where
    Q: QueryType,
    I: serde::de::DeserializeOwned + serde::Serialize,
{
    pub query: Q,
    pub input: Option<I>,
}

impl<Q, I> CombinedInput<Q, I>
where
    Q: QueryType,
    I: serde::de::DeserializeOwned + serde::Serialize,
{
    /// Create a new [`CombinedInput`] instance.
    pub fn new(query: Q, input: Option<I>) -> Self {
        Self { query, input }
    }
}

/// Generated by `cargo expand` from `derive(Deserialize)` on `CombinedInput`.
///
/// Manipulated to allow `'de` lifetime hidden from the public API. The normal
/// `#[derive(Deserialize)]` would not work as it expects all fields to be
/// non-Generic [`serde::Deserialize`] types, which in our case it is, but it
/// could not infer the trait bounds correctly.
///
/// Since we also require both `Q` and `I` to be [`serde::de::DeserializeOwned`]
/// types, we can confine the `'de` lifetime to the hidden implementation.
///
/// # Warning
///
/// This might break if the `serde` crate changes its implementation, or if the
/// `serde` crate changes its API. This is a fragile implementation, and should
/// be used with caution.
///
/// This implementation is generated from 1.0.215 of the `serde` crate.
impl<'de, Q, I> serde::Deserialize<'de> for CombinedInput<Q, I>
where
    Q: QueryType,
    I: serde::de::DeserializeOwned + serde::Serialize,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        enum CombinedInputField {
            Query,
            Input,
            Ignored,
        }
        #[doc(hidden)]
        struct FieldVisitor;
        impl serde::de::Visitor<'_> for FieldVisitor {
            type Value = CombinedInputField;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                std::fmt::Formatter::write_str(formatter, "field identifier")
            }
            fn visit_u64<E>(self, value: u64) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    0u64 => Ok(CombinedInputField::Query),
                    1u64 => Ok(CombinedInputField::Input),
                    _ => Ok(CombinedInputField::Ignored),
                }
            }
            fn visit_str<E>(self, __value: &str) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match __value {
                    "query" => Ok(CombinedInputField::Query),
                    "input" => Ok(CombinedInputField::Input),
                    _ => Ok(CombinedInputField::Ignored),
                }
            }
            fn visit_bytes<E>(self, __value: &[u8]) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match __value {
                    b"query" => Ok(CombinedInputField::Query),
                    b"input" => Ok(CombinedInputField::Input),
                    _ => Ok(CombinedInputField::Ignored),
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for CombinedInputField {
            #[inline]
            fn deserialize<D>(__deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                serde::Deserializer::deserialize_identifier(__deserializer, FieldVisitor)
            }
        }
        #[doc(hidden)]
        struct __Visitor<'de, Q, I>
        where
            Q: QueryType,
            I: serde::de::DeserializeOwned + serde::Serialize,
        {
            marker: std::marker::PhantomData<CombinedInput<Q, I>>,
            lifetime: std::marker::PhantomData<&'de ()>,
        }
        impl<'de, Q, I> serde::de::Visitor<'de> for __Visitor<'de, Q, I>
        where
            Q: QueryType,
            I: serde::de::DeserializeOwned + serde::Serialize,
        {
            type Value = CombinedInput<Q, I>;

            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                std::fmt::Formatter::write_str(formatter, "struct CombinedInput")
            }
            #[inline]
            fn visit_seq<__A>(self, mut seq: __A) -> Result<Self::Value, __A::Error>
            where
                __A: serde::de::SeqAccess<'de>,
            {
                let query = match serde::de::SeqAccess::next_element::<Q>(&mut seq)? {
                    Some(value) => value,
                    None => {
                        return Err(serde::de::Error::invalid_length(
                            0usize,
                            &"struct CombinedInput with 2 elements",
                        ));
                    }
                };
                let input = match serde::de::SeqAccess::next_element::<Option<I>>(&mut seq)? {
                    Some(value) => value,
                    None => {
                        return Err(serde::de::Error::invalid_length(
                            1usize,
                            &"struct CombinedInput with 2 elements",
                        ));
                    }
                };
                Ok(CombinedInput { query, input })
            }
            #[inline]
            fn visit_map<__A>(self, mut map: __A) -> Result<Self::Value, __A::Error>
            where
                __A: serde::de::MapAccess<'de>,
            {
                let mut query: Option<Q> = None;
                let mut input: Option<Option<I>> = None;
                while let Some(key) =
                    serde::de::MapAccess::next_key::<CombinedInputField>(&mut map)?
                {
                    match key {
                        CombinedInputField::Query => {
                            if Option::is_some(&query) {
                                return Err(<__A::Error as serde::de::Error>::duplicate_field(
                                    "query",
                                ));
                            }
                            query = Some(serde::de::MapAccess::next_value::<Q>(&mut map)?);
                        }
                        CombinedInputField::Input => {
                            if Option::is_some(&input) {
                                return Err(<__A::Error as serde::de::Error>::duplicate_field(
                                    "input",
                                ));
                            }
                            input = Some(serde::de::MapAccess::next_value::<Option<I>>(&mut map)?);
                        }
                        _ => {
                            let _ = serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(
                                &mut map,
                            )?;
                        }
                    }
                }
                let query = match query {
                    Some(value) => value,
                    None => serde::__private::de::missing_field("query")?,
                };
                let input = match input {
                    Some(value) => value,
                    None => serde::__private::de::missing_field("input")?,
                };
                Ok(CombinedInput { query, input })
            }
        }
        #[doc(hidden)]
        const FIELDS: &[&str] = &["query", "input"];
        serde::Deserializer::deserialize_struct(
            deserializer,
            "CombinedInput",
            FIELDS,
            __Visitor {
                marker: std::marker::PhantomData::<CombinedInput<Q, I>>,
                lifetime: std::marker::PhantomData,
            },
        )
    }
}
